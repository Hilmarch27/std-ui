{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "csv",
  "type": "registry:lib",
  "title": "Csv",
  "description": "A simple parsed or read csv with zod validation",
  "dependencies": [
    "zod"
  ],
  "files": [
    {
      "path": "src/registry/lib/csv.ts",
      "content": "import { z } from 'zod'\r\n\r\n/**\r\n * Convert error message\r\n */\r\nexport function parseError(errors: Array<{ line: number; error: z.ZodError | Error }> = []) {\r\n  return errors.map(\r\n    (err) =>\r\n      `Line ${err.line}: ${\r\n        err.error instanceof z.ZodError\r\n          ? err.error.errors.map((e) => `${e.path.join('.')}: ${e.message}`).join(', ')\r\n          : err.error.message\r\n      }`\r\n  )\r\n}\r\n\r\n/**\r\n * Parse CSV string into validated JSON objects\r\n * @param csvString The CSV string to parse\r\n * @param schema The Zod schema to validate against\r\n * @param options Parsing options\r\n * @returns Object with parsed valid data and any parsing errors\r\n */\r\n\r\n/**\r\n * Extracts expected field names from a Zod schema\r\n */\r\ntype ExtractFieldNames<T extends z.ZodType> = keyof z.infer<T>\r\n\r\nexport interface ParseCSVOptions<T extends z.ZodType> {\r\n  delimiter?: string\r\n  hasHeaderRow?: boolean\r\n  /**\r\n   * Map CSV headers to schema fields\r\n   * Key: The header name in the CSV\r\n   * Value: The corresponding field name in the schema\r\n   */\r\n  headerMap?: Partial<Record<string, ExtractFieldNames<T>>>\r\n}\r\n\r\n/**\r\n * Parses a CSV string into JSON objects validated against a Zod schema\r\n */\r\nexport function parseCSVToJSON<T extends z.ZodType>(\r\n  csvString: string,\r\n  schema: T,\r\n  options: ParseCSVOptions<T> = {}\r\n): {\r\n  validData: z.infer<T>[]\r\n  errors: Array<{ line: number; error: z.ZodError | Error }>\r\n} {\r\n  const { delimiter = ',', hasHeaderRow = true, headerMap = {} } = options\r\n\r\n  // Split the CSV string into rows\r\n  const rows = csvString.split('\\n').filter((row) => row.trim().length > 0)\r\n  if (rows.length === 0) {\r\n    return { validData: [], errors: [] }\r\n  }\r\n\r\n  // Parse headers\r\n  let headers: string[] = []\r\n  let dataRows = rows\r\n\r\n  if (hasHeaderRow && rows[0]) {\r\n    const headerRow = rows[0]\r\n    headers = headerRow\r\n      .split(delimiter)\r\n      .map((header) => header.trim())\r\n      .map((header) => {\r\n        // Convert CSV header to schema field name using headerMap\r\n        const mappedHeader = headerMap[header]\r\n        return mappedHeader !== undefined ? String(mappedHeader) : header\r\n      })\r\n    dataRows = rows.slice(1)\r\n  }\r\n\r\n  const validData: z.infer<T>[] = []\r\n  const errors: Array<{ line: number; error: z.ZodError | Error }> = []\r\n\r\n  // Process each data row\r\n  dataRows.forEach((row, index) => {\r\n    try {\r\n      // Skip empty rows\r\n      if (row.trim() === '') return\r\n\r\n      const values = row.split(delimiter)\r\n      const rowData: Record<string, string> = {}\r\n\r\n      // If headers are defined, use them as keys\r\n      if (headers.length > 0) {\r\n        headers.forEach((header, i) => {\r\n          if (i < values.length && values[i] !== undefined) {\r\n            // Clean up the value (remove quotes if present)\r\n            let value = values[i].trim()\r\n            if (value.startsWith('\"') && value.endsWith('\"')) {\r\n              value = value.substring(1, value.length - 1).replace(/\"\"/g, '\"')\r\n            }\r\n            rowData[header] = value\r\n          }\r\n        })\r\n      } else {\r\n        // If no headers, use numeric indices as keys\r\n        values.forEach((value, i) => {\r\n          let cleanValue = value.trim()\r\n          if (cleanValue.startsWith('\"') && cleanValue.endsWith('\"')) {\r\n            cleanValue = cleanValue.substring(1, cleanValue.length - 1).replace(/\"\"/g, '\"')\r\n          }\r\n          rowData[String(i)] = cleanValue\r\n        })\r\n      }\r\n\r\n      // Validate the row data against the schema\r\n      const validatedData = schema.parse(rowData)\r\n      validData.push(validatedData)\r\n    } catch (error) {\r\n      errors.push({\r\n        line: hasHeaderRow ? index + 2 : index + 1, // +1 for 0-indexing, +1 for header if present\r\n        error: error instanceof Error ? error : new Error('Unknown error')\r\n      })\r\n    }\r\n  })\r\n\r\n  return { validData, errors }\r\n}\r\n\r\n/**\r\n * Read a CSV file and return its content as a string\r\n * @param file The File object to read\r\n * @returns Promise resolving to the file content as string\r\n */\r\nexport function readCSVFile(file: File): Promise<string> {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader()\r\n\r\n    reader.onload = (event) => {\r\n      if (event.target?.result) {\r\n        resolve(event.target.result as string)\r\n      } else {\r\n        reject(new Error('Failed to read file'))\r\n      }\r\n    }\r\n\r\n    reader.onerror = () => {\r\n      reject(new Error('Error reading file'))\r\n    }\r\n\r\n    reader.readAsText(file)\r\n  })\r\n}\r\n\r\n/**\r\n * Converts data to CSV format and initiates download\r\n * @param data Array of objects to convert to CSV\r\n * @param filename Name of the file to download (without extension)\r\n */\r\nexport interface CSVExportOptions<T> {\r\n  excludeFields?: Array<keyof T>\r\n  headerMapping?: { [K in keyof T]?: string }\r\n  filename?: string\r\n}\r\n\r\nexport function exportToCSV<T extends Record<string, any>>(\r\n  data: T[],\r\n  filenameOrOptions: string | CSVExportOptions<T>\r\n): void {\r\n  // Handle options\r\n  let options: CSVExportOptions<T> = {}\r\n  let filename = 'export'\r\n\r\n  if (typeof filenameOrOptions === 'string') {\r\n    filename = filenameOrOptions\r\n  } else {\r\n    options = filenameOrOptions\r\n    filename = options.filename || 'export'\r\n  }\r\n\r\n  const excludeFields = options.excludeFields || []\r\n  const headerMapping = options.headerMapping || ({} as { [K in keyof T]?: string })\r\n\r\n  if (data.length === 0) {\r\n    alert('No data to export')\r\n    return\r\n  }\r\n\r\n  // Get headers from the first object's keys, excluding specified fields\r\n  const allHeaders = Object.keys(data[0] || {}) as Array<keyof T>\r\n  const headers = allHeaders.filter((header) => !excludeFields.includes(header))\r\n\r\n  // Map headers if header mapping is provided\r\n  const mappedHeaders = headers.map((header) => {\r\n    // Check if this header has a mapping\r\n    return headerMapping[header] || String(header)\r\n  })\r\n\r\n  // Create CSV header row\r\n  const csvRows = [mappedHeaders.join(',')]\r\n\r\n  // Add data rows\r\n  for (const row of data) {\r\n    const values = headers.map((header) => {\r\n      const value = row[header]\r\n      // Handle values that need quotes (contain commas, quotes, or newlines)\r\n      const stringValue = String(value ?? '')\r\n      if (stringValue.includes(',') || stringValue.includes('\"') || stringValue.includes('\\n')) {\r\n        return `\"${stringValue.replace(/\"/g, '\"\"')}\"`\r\n      }\r\n      return stringValue\r\n    })\r\n    csvRows.push(values.join(','))\r\n  }\r\n\r\n  // Combine all rows with newlines\r\n  const csvString = csvRows.join('\\n')\r\n\r\n  // Create a blob with the CSV data\r\n  const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' })\r\n\r\n  // Create a download link\r\n  const link = document.createElement('a')\r\n\r\n  // Support for browsers that have the URL API\r\n  if (window.URL && URL.createObjectURL) {\r\n    link.href = URL.createObjectURL(blob)\r\n    link.download = `${filename}.csv`\r\n    document.body.appendChild(link)\r\n    link.click()\r\n    document.body.removeChild(link)\r\n    URL.revokeObjectURL(link.href)\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    }
  ]
}